<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <meta content="ie=edge" http-equiv="x-ua-compatible"/>
  <meta content="Copy to clipboard" name="lang:clipboard.copy"/>
  <meta content="Copied to clipboard" name="lang:clipboard.copied"/>
  <meta content="en" name="lang:search.language"/>
  <meta content="True" name="lang:search.pipeline.stopwords"/>
  <meta content="True" name="lang:search.pipeline.trimmer"/>
  <meta content="No matching documents" name="lang:search.result.none"/>
  <meta content="1 matching document" name="lang:search.result.one"/>
  <meta content="# matching documents" name="lang:search.result.other"/>
  <meta content="[\s\-]+" name="lang:search.tokenizer"/>
  <link crossorigin="" href="https://fonts.gstatic.com/" rel="preconnect"/>
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&amp;display=fallback" rel="stylesheet"/>
  <style>
   body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
  </style>
  <link href="../../../_static/stylesheets/application.css" rel="stylesheet"/>
  <link href="../../../_static/stylesheets/application-palette.css" rel="stylesheet"/>
  <link href="../../../_static/stylesheets/application-fixes.css" rel="stylesheet"/>
  <link href="../../../_static/fonts/material-icons.css" rel="stylesheet"/>
  <meta content="#3f51b5" name="theme-color"/>
  <script src="../../../_static/javascripts/modernizr.js">
  </script>
  <title>
   lnn.symbolic.logic — Logical Neural Networks Docs
  </title>
  <link href="../../../_static/pygments.css" rel="stylesheet" type="text/css"/>
  <link href="../../../_static/material.css" rel="stylesheet" type="text/css"/>
  <link href="../../../_static/copybutton.css" rel="stylesheet" type="text/css"/>
  <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js">
  </script>
  <script src="../../../_static/jquery.js">
  </script>
  <script src="../../../_static/underscore.js">
  </script>
  <script src="../../../_static/doctools.js">
  </script>
  <script src="../../../_static/clipboard.min.js">
  </script>
  <script src="../../../_static/copybutton.js">
  </script>
  <link href="../../../genindex.html" rel="index" title="Index"/>
  <link href="../../../search.html" rel="search" title="Search"/>
 </head>
 <body data-md-color-accent="cyan" data-md-color-primary="blue" dir="ltr">
  <svg class="md-svg">
   <defs data-children-count="0">
    <svg height="448" id="__github" viewbox="0 0 416 448" width="416" xmlns="http://www.w3.org/2000/svg">
     <path d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z" fill="currentColor">
     </path>
    </svg>
   </defs>
  </svg>
  <input class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
  <input class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
  <label class="md-overlay" data-md-component="overlay" for="__drawer">
  </label>
  <a class="md-skip" href="#_modules/lnn/symbolic/logic" tabindex="1">
   Skip to content
  </a>
  <header class="md-header" data-md-component="header">
   <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
     <div class="md-flex__cell md-flex__cell--shrink">
      <a class="md-header-nav__button md-logo" href="../../../index.html" title="Logical Neural Networks Docs">
      </a>
     </div>
     <div class="md-flex__cell md-flex__cell--shrink">
      <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer">
      </label>
     </div>
     <div class="md-flex__cell md-flex__cell--stretch">
      <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
       <span class="md-header-nav__topic">
        Logical Neural Networks
       </span>
       <span class="md-header-nav__topic">
        lnn.symbolic.logic
       </span>
      </div>
     </div>
     <div class="md-flex__cell md-flex__cell--shrink">
      <label class="md-icon md-icon--search md-header-nav__button" for="__search">
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
       <label class="md-search__overlay" for="__search">
       </label>
       <div class="md-search__inner" role="search">
        <form action="../../../search.html" class="md-search__form" method="get" name="search">
         <input autocapitalize="off" autocomplete="off" class="md-search__input" data-md-component="query" data-md-state="active" name="q" placeholder="Search" spellcheck="false" type="text"/>
         <label class="md-icon md-search__icon" for="__search">
         </label>
         <button class="md-icon md-search__icon" data-md-component="reset" tabindex="-1" type="reset">
          
         </button>
        </form>
        <div class="md-search__output">
         <div class="md-search__scrollwrap" data-md-scrollfix="">
          <div class="md-search-result" data-md-component="result">
           <div class="md-search-result__meta">
            Type to start searching
           </div>
           <ol class="md-search-result__list">
           </ol>
          </div>
         </div>
        </div>
       </div>
      </div>
     </div>
     <div class="md-flex__cell md-flex__cell--shrink">
      <div class="md-header-nav__source">
       <a class="md-source" data-md-source="github" href="https://github.com/IBM/LNN/tree/develop" title="Go to repository">
        <div class="md-source__icon">
         <svg height="28" viewbox="0 0 24 24" width="28" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <use height="24" width="24" xlink:href="#__github">
          </use>
         </svg>
        </div>
        <div class="md-source__repository">
         LNN
        </div>
       </a>
      </div>
     </div>
     <script src="../../../_static/javascripts/version_dropdown.js">
     </script>
     <script>
      var json_loc = "../../../"versions.json"",
        target_loc = "../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
     </script>
    </div>
   </nav>
  </header>
  <div class="md-container">
   <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
     <ul class="md-tabs__list">
      <li class="md-tabs__item">
       <a class="md-tabs__link" href="../../../index.html">
        Logical Neural Networks Docs
       </a>
      </li>
      <li class="md-tabs__item">
       <a class="md-tabs__link" href="../../index.html">
        Module code
       </a>
      </li>
     </ul>
    </div>
   </nav>
   <main class="md-main">
    <div class="md-main__inner md-grid" data-md-component="container">
     <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
      <div class="md-sidebar__scrollwrap">
       <div class="md-sidebar__inner">
        <nav class="md-nav md-nav--primary" data-md-level="0">
         <label class="md-nav__title md-nav__title--site" for="__drawer">
          <a class="md-nav__button md-logo" href="../../../index.html" title="Logical Neural Networks Docs">
           <img alt=" logo" height="48" src="../../../_static/" width="48"/>
          </a>
          <a href="../../../index.html" title="Logical Neural Networks Docs">
           Logical Neural Networks
          </a>
         </label>
         <div class="md-nav__source">
          <a class="md-source" data-md-source="github" href="https://github.com/IBM/LNN/tree/develop" title="Go to repository">
           <div class="md-source__icon">
            <svg height="28" viewbox="0 0 24 24" width="28" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
             <use height="24" width="24" xlink:href="#__github">
             </use>
            </svg>
           </div>
           <div class="md-source__repository">
            LNN
           </div>
          </a>
         </div>
         <ul class="md-nav__list">
          <li class="md-nav__item">
           <a class="md-nav__link" href="../../../introduction.html">
            Logical Neural Networks
           </a>
          </li>
          <li class="md-nav__item">
           <a class="md-nav__link" href="../../../usage.html">
            Python API
           </a>
          </li>
          <li class="md-nav__item">
           <a class="md-nav__link" href="../../../papers.html">
            Papers
           </a>
          </li>
          <li class="md-nav__item">
           <a class="md-nav__link" href="../../../education/education.html">
            Education
           </a>
          </li>
          <li class="md-nav__item">
           <a class="md-nav__link" href="../../../lnn/LNN.html">
            LNN Module
           </a>
          </li>
         </ul>
        </nav>
       </div>
      </div>
     </div>
     <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
      <div class="md-sidebar__scrollwrap">
       <div class="md-sidebar__inner">
        <nav class="md-nav md-nav--secondary">
         <ul class="md-nav__list" data-md-scrollfix="">
          <li class="md-nav__item" id="searchbox">
          </li>
         </ul>
        </nav>
       </div>
      </div>
     </div>
     <div class="md-content">
      <article class="md-content__inner md-typeset" role="main">
       <h1 id="modules-lnn-symbolic-logic--page-root">
        Source code for lnn.symbolic.logic
       </h1>
       <div class="highlight">
        <pre>
<span></span><span class="c1">##</span>
<span class="c1"># Copyright 2021 IBM Corp. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: Apache-2.0</span>
<span class="c1">##</span>

<span class="c1"># flake8: noqa: E501</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_gm</span><span class="p">,</span> <span class="n">_trace</span>
<span class="kn">from</span> <span class="nn">._bindings</span> <span class="kn">import</span> <span class="n">get_bindings</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">_utils</span><span class="p">,</span> <span class="n">_exceptions</span><span class="p">,</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">..constants</span> <span class="kn">import</span> <span class="n">Fact</span><span class="p">,</span> <span class="n">World</span><span class="p">,</span> <span class="n">Direction</span><span class="p">,</span> <span class="n">Join</span><span class="p">,</span> <span class="n">NeuralActivation</span><span class="p">,</span> <span class="n">Bound</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">_utils</span><span class="o">.</span><span class="n">logger_setup</span><span class="p">()</span>


<span class="c1">##</span>
<span class="c1"># Internal Classes</span>
<span class="c1">#</span>
<span class="c1"># All classes below are protected classes (denoted with a prefixed underscore)</span>
<span class="c1"># they follow the convention that they will be kept as internal classes rather than</span>
<span class="c1"># exposing them to the end-user as an API.</span>
<span class="c1"># The formulas are ordered according to the inheritance structure in</span>
<span class="c1"># https://ibm.github.io/LNN/lnn/LNN.html</span>
<span class="c1">##</span>


<div class="viewcode-block" id="Formula"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula">[docs]</a><span class="k">class</span> <span class="nc">Formula</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">"""Symbolic container for a generic formula.</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    Formula should not be directly instantiated. The following class is automatically inherited for all formula in the [symbolic hierarchy](LNN.html#symbolic-structure). This class would ordinarily be a protected class but is exposed purely for documentation purposes, i.e., to show all the functionality (attributes and parameters) that is generally available to all instantiated formulae.</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formulae</span><span class="p">:</span> <span class="s2">"Formula"</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">""</span><span class="p">,</span> <span class="n">arity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span>
    <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">:</span> <span class="n">Join</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"join"</span><span class="p">,</span> <span class="n">Join</span><span class="o">.</span><span class="n">INNER</span><span class="p">)</span>

        <span class="c1"># construct edge and operand list for each formula</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Formula</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># formula arity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">arity</span>

        <span class="c1"># inherit propositional, variables, and graphs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"propositional"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inherit_from_subformulae</span><span class="p">(</span><span class="o">*</span><span class="n">formulae</span><span class="p">)</span>

        <span class="c1"># formula naming</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_LeafFormula</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formula_structure</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formula_structure</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># formula grounding table maps grounded objects to table rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># placeholder for neural variables and functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_inv</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operands_by_number</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">congruent_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="c1">##</span>
    <span class="c1"># External function definitions</span>
    <span class="c1">##</span>

    <span class="k">def</span> <span class="nf">add_facts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"`add_facts` is deprecated, use `add_data` instead"</span><span class="p">)</span>

<div class="viewcode-block" id="Formula.add_data"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.add_data">[docs]</a>    <span class="k">def</span> <span class="nf">add_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">Fact</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
            <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="n">Fact</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]],</span>
        <span class="p">],</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Add data to the formula in the form of classical facts or belief bounds.</span>

<span class="sd">        Data given is a Fact or belief bounds assumes a propositional formula.</span>
<span class="sd">        Data given in a dict assumes a first-order logic formula,</span>
<span class="sd">            keyed by the grounding and a value given as a Fact or belief bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : Fact, belief bounds or dict</span>
<span class="sd">            For propositional formulae, truths is given as either Facts or belief bounds (a tuple of 2 floats). For first-order logic formula, inputs truths are given as a dict. It is keyed by the grounding (a str for unary formlae or tuple of strings of larger arities), with values also as Facts or bounds on beliefs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ```python</span>
<span class="sd">        # propositional</span>
<span class="sd">        P, Q = Propositions("P", "Q")</span>
<span class="sd">        P.add_data(Fact.TRUE)</span>
<span class="sd">        Q.add_data((.1, .4))</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        # first-order logic</span>
<span class="sd">        Person = Predicate("Person")</span>
<span class="sd">        Person.add_data({</span>
<span class="sd">            "Barack Obama": Fact.TRUE,</span>
<span class="sd">            "Bo": (.1, .4)</span>
<span class="sd">        })</span>

<span class="sd">        # FOL with arity &gt; 2</span>
<span class="sd">        BD = Predicate("Birthdate", 2)</span>
<span class="sd">        BD.add_data({</span>
<span class="sd">            ("Barack Obama", "04 August 1961"): Fact.TRUE,</span>
<span class="sd">            ("Bo", "09 October 2008"): (.6, .75)</span>
<span class="sd">        })</span>
<span class="sd">        ```</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>  <span class="c1"># Propositional facts</span>
            <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertBounds</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># FOL facts</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>  <span class="c1"># facts given per grounding</span>
                <span class="c1"># replace fact keys (str -&gt; _Groundings)</span>
                <span class="n">groundings</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ground</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

                <span class="c1"># add missing groundings to `grounding_table`</span>
                <span class="n">groundings</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_groundings</span><span class="p">(</span><span class="o">*</span><span class="n">groundings</span><span class="p">)</span>

                <span class="c1"># set facts for all groundings</span>
                <span class="n">table_facts</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="p">[</span><span class="n">g</span><span class="p">]:</span> <span class="n">data</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">"FOL facts should be from [dict, set], "</span>
                    <span class="sa">f</span><span class="s1">'"</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">" received </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s1">'</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">table_facts</span><span class="p">)</span></div>

<div class="viewcode-block" id="Formula.add_labels"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.add_labels">[docs]</a>    <span class="k">def</span> <span class="nf">add_labels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">Fact</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
            <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="n">Fact</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]],</span>
        <span class="p">],</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Store labels as data within the symbolic container.</span>

<span class="sd">        Labels given is a Fact or belief bounds assumes a propositional formula.</span>
<span class="sd">        Labels given in a dict assumes a first-order logic formula,</span>
<span class="sd">            keyed by the grounding and a value given as a Fact or belief bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : Fact, belief bounds or dict</span>
<span class="sd">            For propositional formulae, facts are given as either Facts or bounds on beliefs (a tuple of 2 floats). For first-order logic formula, inputs are given as a dict. It is keyed by the grounding (a str for unary formlae or tuple of strings of larger arities), with values also as Facts or bounds on beliefs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ```python</span>
<span class="sd">        # propositional</span>
<span class="sd">        P, Q = Propositions("P", "Q")</span>
<span class="sd">        P.add_labels(Fact.TRUE)</span>
<span class="sd">        Q.add_labels((.1, .4))</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        # first-order logic</span>
<span class="sd">        Person = Predicate("Person")</span>
<span class="sd">        Person.add_labels({</span>
<span class="sd">            "Barack Obama": Fact.TRUE,</span>
<span class="sd">            "Bo": (.1, .4)</span>
<span class="sd">        })</span>

<span class="sd">        # FOL with arity &gt; 2</span>
<span class="sd">        BD = Predicate("Birthdate", 2)</span>
<span class="sd">        BD.add_labels({</span>
<span class="sd">            ("Barack Obama", "04 August 1961"): Fact.TRUE,</span>
<span class="sd">            ("Bo", "09 October 2008"): (.6, .75)</span>
<span class="sd">        })</span>
<span class="sd">        ```</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>  <span class="c1"># Propositional labels</span>
            <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertBounds</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">fact_to_bounds</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># FOL labels</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"labels"</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>  <span class="c1"># labels given per grounding</span>
                <span class="n">_labels</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_labels</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="c1"># set labels for groundings, replace str keys -&gt; Groundings</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ground</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">fact_to_bounds</span><span class="p">(</span>
                        <span class="n">_labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">"FOL facts should be from [dict, set], "</span>
                    <span class="sa">f</span><span class="s1">'"</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">" received </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="si">}</span><span class="s1">'</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Formula.flush"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.flush">[docs]</a>    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Set all facts in formula to `Fact.UNKNOWN`."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">get_facts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"`get_facts` is deprecated, use `get_data` instead"</span><span class="p">)</span>

<div class="viewcode-block" id="Formula.get_data"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">groundings</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="s2">"_Grounding"</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns the current beliefs of the formula.</span>

<span class="sd">        Uses the given groundings or the entire `groundind_table` to slice out the</span>
<span class="sd">        current belief bounds from the `bounds_table`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------</span>
<span class="sd">        ``*groundings``: str or tuple of str</span>
<span class="sd">            NB - if unspecified, defaults to returning all the facts for the given formula. If specified, the table will be ordered according to the input grounding order.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">groundings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="n">table_rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ground</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">row</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table_rows</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">table_rows</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Formula.get_labels"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.get_labels">[docs]</a>    <span class="k">def</span> <span class="nf">get_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">groundings</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns the stored labels from the symbolic container."""</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">groundings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ground</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groundings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">result</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">groundings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]:</span>
        <span class="sa">r</span><span class="sd">"""Returns the groundings to the user as str or tuple of str."""</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_Grounding</span><span class="o">.</span><span class="n">eval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_classically_resolved</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Checks if the query node is in a classical state besides `Fact.UNKNOWN`."""</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span> <span class="ow">and</span> <span class="n">_utils</span><span class="o">.</span><span class="n">is_classical_proposition</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Formula.is_contradiction"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.is_contradiction">[docs]</a>    <span class="k">def</span> <span class="nf">is_contradiction</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">stacked</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">BoolTensor</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Check if bounds are in contradiction."""</span>
        <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">dim</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Formula.is_equal"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.is_equal">[docs]</a>    <span class="k">def</span> <span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">"Formula"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns True if two nodes are symbolically equivalent.</span>

<span class="sd">        Formulae can be symbolically equivalent yet neurally different, example:</span>
<span class="sd">        ```python</span>
<span class="sd">        f = And(A, B, activation={"type": NeuralActivation.Lukasiewicz})</span>
<span class="sd">        g = And(A, B, activation={"type": NeuralActivation.Godel})</span>
<span class="sd">        ```</span>
<span class="sd">        The above will return `True`, since `f` is symbolically equivalent to `g`</span>
<span class="sd">        despite different neural configurations.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">congruent_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Congruent</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="n">operand</span><span class="o">.</span><span class="n">structure</span> <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">operands</span>
                <span class="p">]</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">is_unweighted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">bias</span> <span class="o">==</span> <span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">weights</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">negation_absorption</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s2">"Formula"</span><span class="p">]]):</span>
        <span class="n">n_negations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edge_replace</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">operands</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="n">formula</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">formula</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Not</span><span class="p">):</span>
                    <span class="n">recurse</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
                    <span class="n">root_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_negations</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">n_negations</span><span class="p">[</span><span class="n">root_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">condition</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
                    <span class="n">condition</span><span class="p">[</span><span class="n">root_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">root_idx</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">update_weights_where</span><span class="p">(</span>
                            <span class="n">condition</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">weights</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">root_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">root_idx</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">edge_replace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_list</span><span class="p">[</span><span class="n">root_idx</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">root_idx</span><span class="p">]))</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n_negations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>

        <span class="n">recurse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge_replace</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ABSORBED NEGATIONS INTO WEIGHTS FOR: '</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">'"</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">edge_replace</span><span class="p">,</span> <span class="n">n_negations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">operands</span><span class="p">,</span> <span class="n">edge_replace</span><span class="p">,</span> <span class="n">n_negations</span>

    <span class="k">def</span> <span class="nf">named_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">param</span>

    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">detach</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">()):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">detach</span>
                    <span class="k">else</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> has no attribute: </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">result</span>

<div class="viewcode-block" id="Formula.print"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.print">[docs]</a>    <span class="k">def</span> <span class="nf">print</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">header_len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">roundoff</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">grads</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">numbering</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Print the states of groundings in a formula.</span>

<span class="sd">        ```</span>
<span class="sd">        OPEN   Proposition: A                 UNKNOWN (L, U)</span>

<span class="sd">        CLOSED Proposition: B                   FALSE (L, U)</span>

<span class="sd">        OPEN   Predicate: P1 (x)</span>
<span class="sd">        "const_1"                                TRUE (L, U)</span>
<span class="sd">        "const_2"                       CONTRADICTION (L, U)</span>
<span class="sd">        "const_3"                               FALSE (L, U)</span>

<span class="sd">        OPEN   Predicate: P2 (x, y)</span>
<span class="sd">        ("const_1", "const_5")                   TRUE (L, U)</span>
<span class="sd">        ("const_2", "const_6")          CONTRADICTION (L, U)</span>
<span class="sd">        ("const_3", "const_7")                  FALSE (L, U)</span>

<span class="sd">        OPEN   And: And_0 (x, y)</span>
<span class="sd">        Bindings: P1 (x: "const_1"), P2 (x: 'const_2', y: ['const_3', ...])</span>
<span class="sd">        ('const_1', 'const_3')                   TRUE (L, U)</span>
<span class="sd">        ('const_2', 'const_3')          CONTRADICTION (L, U)</span>
<span class="sd">        ('const_1', 'const_7')                  FALSE (L, U)</span>

<span class="sd">        TRUE   ForAll: ForAll_0 (y)           UNKNOWN (L, U)</span>
<span class="sd">        ```</span>

<span class="sd">        """</span>

        <span class="k">def</span> <span class="nf">state_wrapper</span><span class="p">(</span><span class="n">grounding</span><span class="p">:</span> <span class="n">_Grounding</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">"'</span><span class="si">{</span><span class="n">grounding</span><span class="si">}</span><span class="s2">'"</span> <span class="k">if</span> <span class="n">grounding</span><span class="o">.</span><span class="n">grounding_arity</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">grounding</span><span class="si">}</span><span class="s2">"</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">round_bounds</span><span class="p">(</span><span class="n">grounding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="nb">round</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">roundoff</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">grounding</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span>
                        <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">grounding</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="n">header</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_state</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span><span class="si">}</span><span class="s2"> "</span>
            <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">"</span>
            <span class="sa">f</span><span class="s2">": </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">_utils</span><span class="o">.</span><span class="n">param_symbols</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">params</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">roundoff</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span> <span class="o">+</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">" grads </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">roundoff</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
                        <span class="k">if</span> <span class="n">grads</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">grad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="s2">""</span>
                    <span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="s2">"params  "</span> <span class="o">+</span> <span class="s2">",  "</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">"</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="s2">""</span>
        <span class="n">number</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operands_by_number</span><span class="si">}</span><span class="s2">: "</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">numbering</span>
            <span class="k">else</span> <span class="s2">""</span>
        <span class="p">)</span>

        <span class="c1"># print propositional node - single bounds</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
            <span class="n">states</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">header</span><span class="si">:</span><span class="s2">&lt;</span><span class="si">{</span><span class="n">header_len</span><span class="si">}}</span><span class="s2"> "</span>
                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;13</span><span class="si">}</span><span class="s2"> "</span>
                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">round_bounds</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span>
                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">"</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">number</span><span class="si">}{</span><span class="n">states</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

        <span class="c1"># print FOL node - table of bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">facts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="s2">""</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">state_wrapper</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="si">:{</span><span class="n">header_len</span><span class="si">}}</span><span class="s2"> "</span>
                            <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;13</span><span class="si">}</span><span class="s2"> "</span>
                            <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">round_bounds</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">binder</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">op_idx</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_bindings</span><span class="p">(</span><span class="n">op_idx</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_remap</span><span class="p">[</span><span class="n">op_idx</span><span class="p">])):</span>
                        <span class="k">if</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">op_idx</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">binder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="si">}</span><span class="s2"> "</span>
                                <span class="s2">"{"</span>
                                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand_map</span><span class="p">[</span><span class="n">op_idx</span><span class="p">][</span><span class="n">i</span><span class="p">])</span><span class="si">}</span><span class="s2">: "</span>
                                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">op_idx</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span><span class="si">}</span><span class="s2">"</span>
                                <span class="s2">"}"</span>
                            <span class="p">)</span>
            <span class="n">bind_str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">Bindings: "</span> <span class="o">+</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">binder</span><span class="p">))</span> <span class="k">if</span> <span class="n">binder</span> <span class="k">else</span> <span class="s2">""</span>
            <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">bind_str</span><span class="si">}</span><span class="s2">"</span>
            <span class="n">params</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="se">\n</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">"</span> <span class="k">if</span> <span class="n">params</span> <span class="k">else</span> <span class="s2">""</span>
            <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">header</span><span class="si">}{</span><span class="n">params</span><span class="si">}</span><span class="s2">"</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span> <span class="o">+</span> <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">facts</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">number</span><span class="si">}{</span><span class="n">result</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">project_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">project_params</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">reset_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">reset_bounds</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset_world</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world</span><span class="p">:</span> <span class="n">World</span><span class="p">):</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertBoundsLen</span><span class="p">(</span><span class="n">world</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">world</span> <span class="o">=</span> <span class="n">world</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">world</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">reset_world</span><span class="p">(</span><span class="n">world</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_formula_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">operand</span><span class="o">.</span><span class="n">formula_number</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">set_formula_number</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operands_by_number</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">formula_number</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">set_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">join</span><span class="p">:</span> <span class="n">Join</span><span class="p">):</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertJoin</span><span class="p">(</span><span class="n">join</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">join</span> <span class="o">=</span> <span class="n">join</span>

<div class="viewcode-block" id="Formula.set_negative_weights"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.set_negative_weights">[docs]</a>    <span class="k">def</span> <span class="nf">set_negative_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">is_negative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">store</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s2">"Formula"</span><span class="p">]]):</span>
        <span class="sd">"""absorb `Not` into weights and allow negative computation"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">set_negative_weights</span><span class="p">(</span><span class="n">is_negative</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">negation_absorption</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="n">store</span><span class="p">)</span></div>

<div class="viewcode-block" id="Formula.set_propositional"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.set_propositional">[docs]</a>    <span class="k">def</span> <span class="nf">set_propositional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">propositional</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Set's the neuron's world parameter."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span> <span class="o">=</span> <span class="n">propositional</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">bounds_table</span><span class="o">.</span><span class="n">shape</span>

<div class="viewcode-block" id="Formula.state"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.state">[docs]</a>    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">groundings</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">to_bool</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bounds</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
        <span class="sa">r</span><span class="sd">"""Returns the state of a single grounded fact.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        groundings : groundings, optional</span>
<span class="sd">            If unspecified, will return the state of all groundings.</span>
<span class="sd">        bounds: torch.Tensor, optional</span>
<span class="sd">            Forces the function to return the state of the given tensor. If unspecified, will return the bounds tensor currently stored in the node.</span>
<span class="sd">        to_bool : bool, optional.</span>
<span class="sd">            If to_bool flag is True, will map classical Facts to bool: i.e. {Fact.True: True, FALSE': False}. The states that cannot be converted to bool will return as str, e.g. `'APPROX_TRUE'`. If unspecified, will not convert to bool.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        see section [F.2](https://arxiv.org/abs/2006.13155) for more</span>
<span class="sd">            information on node states</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">groundings</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groundings</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span> <span class="k">if</span> <span class="n">groundings</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">groundings</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                    <span class="k">return</span> <span class="n">result</span>
                <span class="n">groundings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ground</span><span class="p">(</span><span class="n">groundings</span><span class="p">)</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">groundings</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"grounding </span><span class="si">{</span><span class="n">groundings</span><span class="si">}</span><span class="s2"> not found in </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">node_state</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">fact_to_bool</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">if</span> <span class="n">to_bool</span> <span class="k">else</span> <span class="n">result</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variable_slots</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">)}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_Quantifier</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">world</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">World</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Proxy to get the neuron's world parameter."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">world</span>

    <span class="nd">@world</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">world</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_world</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">,</span> <span class="n">World</span><span class="p">]):</span>
        <span class="sa">r</span><span class="sd">"""Proxy to set the neuron's world parameter."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">world</span> <span class="o">=</span> <span class="n">new_world</span>

<div class="viewcode-block" id="Formula.world_state"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Formula.world_state">[docs]</a>    <span class="k">def</span> <span class="nf">world_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Returns the state of the `world` variable."""</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">World</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="n">w</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">world</span></div>

    <span class="k">def</span> <span class="nf">And</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formulae</span><span class="p">:</span> <span class="s2">"Formula"</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"And"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_formula_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formulae</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formulae</span><span class="p">:</span> <span class="s2">"Formula"</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"Or"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Or</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_formula_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formulae</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Implies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">:</span> <span class="s2">"Formula"</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"Implies"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Implies</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_formula_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Not</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"Not"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Not</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_formula_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Equivalent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">:</span> <span class="s2">"Formula"</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"Equivalent"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Equivalent</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_formula_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"Exists"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ForAll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"ForAll"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ForAll</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="c1">##</span>
    <span class="c1"># Internal function definitions</span>
    <span class="c1">##</span>

    <span class="n">CalledFormula</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
        <span class="s2">"CalledFormula"</span><span class="p">,</span>
        <span class="n">bound</span><span class="o">=</span><span class="n">Union</span><span class="p">[</span>
            <span class="n">Tuple</span><span class="p">[</span>
                <span class="s2">"Formula"</span><span class="p">,</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">"_Grounding"</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="kc">None</span><span class="p">]]]],</span>
            <span class="p">],</span>
        <span class="p">],</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">variables</span><span class="p">:</span> <span class="s2">"Variable"</span><span class="p">,</span>
        <span class="n">bind</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CalledFormula</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Variable remapping between operator and operand variables.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        FOL formulae that appear in connectives are callable:</span>
<span class="sd">            Note `A`, `B` in the `And`</span>
<span class="sd">        ```python</span>
<span class="sd">        x = Variable('x')</span>
<span class="sd">        model['A'] = Predicate('A')</span>
<span class="sd">        model['B'] = Predicate('B')</span>
<span class="sd">        model['AB'] = And(A(x), B(x))</span>
<span class="sd">        ```</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Formula:</span>
<span class="sd">            reference to the child object</span>
<span class="sd">        variables:</span>
<span class="sd">            tuple of child's Variables</span>
<span class="sd">        var_remap:</span>
<span class="sd">            tuple of parent-to-child remapping Variables</span>
<span class="sd">        bindings:</span>
<span class="sd">            tuple of parent-to-child groundings to bind inference to single groundings are _Grounding multiple groundings are list(_Grounding)</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_unique_vars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">"please check if the FOL arity of </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is correctly set for the "</span>
                <span class="sa">f</span><span class="s2">"number of variables, length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span><span class="si">}</span><span class="s2">) must be the same "</span>
                <span class="sa">f</span><span class="s2">"length as `num_unique_vars` (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_unique_vars</span><span class="si">}</span><span class="s2">)"</span>
            <span class="p">)</span>
        <span class="n">bindings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bind</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"expected variable, received </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bind</span><span class="p">:</span>  <span class="c1"># extract bindings</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bind</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># a single binding</span>
                    <span class="n">bindings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_ground</span><span class="p">(</span><span class="n">bind</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">arity_match</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bind</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>  <span class="c1"># multiple bindings</span>
                    <span class="n">bindings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ground</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">arity_match</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">bind</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bind</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">Function</span><span class="p">):</span>  <span class="c1"># A single function</span>
                    <span class="n">bindings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bind</span><span class="p">[</span><span class="n">v</span><span class="p">]])</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bind</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># A bound function</span>
                    <span class="n">bindings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bind</span><span class="p">[</span><span class="n">v</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">"bindings expected as str, "</span>
                        <span class="sa">f</span><span class="s2">"Function or list of str or "</span>
                        <span class="sa">f</span><span class="s2">"Function, received </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">bind</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="si">}</span><span class="s2">"</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bindings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">bindings</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">_add_groundings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">groundings</span><span class="p">:</span> <span class="s2">"_Grounding"</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Adds missing groundings to `grounding_table` for those not yet stored.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ```python</span>
<span class="sd">        # for formulae with arity == 1:</span>
<span class="sd">        formula._add_groundings(_Grounding_1, _Grounding_2)</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        # for formulae with arity &gt; 1:</span>
<span class="sd">        groundings = ((_Grounding_1, _Grounding_7),</span>
<span class="sd">                      (_Grounding_2, _Grounding_8))</span>
<span class="sd">        formula._add_groundings(*groundings)</span>
<span class="sd">        ```</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        groundings must be given in grounded form: `self._ground(grounding)`</span>

<span class="sd">        """</span>
        <span class="n">missing_groundings</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span> <span class="k">if</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_groundings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_new_groundings</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_new_groundings</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">table_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">extend_groundings</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_groundings</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="n">g</span><span class="p">:</span> <span class="n">table_rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">missing_groundings</span><span class="p">)}</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_formula_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_int</span><span class="p">,</span> <span class="n">get_str</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Determine a name for input formula(e)."""</span>

        <span class="k">def</span> <span class="nf">subformula_structure</span><span class="p">(</span>
            <span class="n">subformula</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span>
            <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">subformula_vars</span><span class="p">:</span> <span class="n">Tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">root_var_remap</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subformula_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">root_var_remap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">expanded_unique_vars</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_Quantifier</span><span class="p">)</span>
                        <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subformula</span><span class="p">,</span> <span class="n">_Quantifier</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">subformula</span><span class="o">.</span><span class="n">expanded_unique_vars</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">root_var_remap</span><span class="p">:</span>
                            <span class="n">root_var_remap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">if</span> <span class="n">subformula_vars</span> <span class="o">!=</span> <span class="n">subformula</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">:</span>
                    <span class="n">root_var_remap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="p">(</span>
                                <span class="n">subformula</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                <span class="n">root_var_remap</span><span class="p">[</span><span class="n">subformula_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="n">subformula</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">subformula_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">else</span> <span class="p">(</span><span class="n">subformula_vars</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">subformula_vars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subformula_vars</span><span class="p">))</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">("</span>
                    <span class="o">+</span> <span class="n">_utils</span><span class="o">.</span><span class="n">list_to_str</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">root_var_remap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">as_int</span>
                            <span class="k">else</span> <span class="n">subformula</span><span class="o">.</span><span class="n">variable_slots</span><span class="p">[</span><span class="n">root_var_remap</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subformula</span><span class="p">,</span> <span class="n">_Quantifier</span><span class="p">)</span>
                            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_slots</span><span class="p">[</span><span class="n">root_var_remap</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span>
                            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span>
                                <span class="n">subformula</span><span class="o">.</span><span class="n">expanded_unique_vars</span><span class="p">[</span><span class="n">_</span><span class="p">]</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subformula</span><span class="p">,</span> <span class="n">_Quantifier</span><span class="p">)</span>
                                <span class="k">else</span> <span class="n">subformula</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">[</span><span class="n">_</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">subformula</span><span class="o">.</span><span class="n">operand_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="p">]</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="o">+</span> <span class="s2">")"</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">)</span>
                <span class="k">else</span> <span class="sa">f</span><span class="s2">"(</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">structure</span><span class="si">}</span><span class="s2">)"</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">_Quantifier</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">(</span>
                    <span class="s2">"("</span>
                    <span class="o">+</span> <span class="n">subformula_structure</span><span class="p">(</span>
                        <span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">operator_str</span><span class="p">,</span> <span class="n">subformula</span><span class="o">.</span><span class="n">var_remap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">root_var_remap</span>
                    <span class="p">)</span>
                    <span class="o">+</span> <span class="s2">")"</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">_ConnectiveNeuron</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">operator_str</span><span class="si">}</span><span class="s2">"</span>
                    <span class="o">+</span> <span class="n">subformula_structure</span><span class="p">(</span>
                        <span class="n">f</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">subformula</span><span class="o">.</span><span class="n">var_remap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">root_var_remap</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Not</span><span class="p">)</span>
                <span class="k">else</span> <span class="s2">""</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subformula</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">" </span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s2"> "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">if</span> <span class="n">operator</span> <span class="k">else</span> <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_Quantifier</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">"(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">quantified_variable</span><span class="si">}</span><span class="s2">, "</span>
                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">subformula_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Not</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span><span class="si">}{</span><span class="n">get_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">"</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span>
                <span class="k">else</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span><span class="si">}{</span><span class="n">subformula_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">"("</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">" </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span><span class="si">}</span><span class="s2"> "</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">get_str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">])</span>
                <span class="o">+</span> <span class="s2">")"</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span>
            <span class="k">else</span> <span class="sa">f</span><span class="s2">"(</span><span class="si">{</span><span class="n">subformula_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_formula_vars</span><span class="p">(</span><span class="o">*</span><span class="n">formulae</span><span class="p">:</span> <span class="s2">"Formula"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">"Formula"</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">]]:</span>
        <span class="sa">r</span><span class="sd">"""Returns a list of formulae as wither called (when predicates)</span>
<span class="sd">        or uncalled as connectives.</span>
<span class="sd">        """</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">"?</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">arity</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">formulae</span><span class="p">]))</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">variables</span><span class="p">[:</span> <span class="n">f</span><span class="o">.</span><span class="n">arity</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">propositional</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">))</span>
            <span class="k">else</span> <span class="n">f</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">formulae</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_ground</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">grounding</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="s2">"_Grounding"</span><span class="p">],</span>
        <span class="n">arity_match</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"_Grounding"</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns a single grounded object given a grounding in str form.</span>

<span class="sd">        If the grounding is already an internal "Grounding" object, it will simply be</span>
<span class="sd">        returned to the user as is.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ```python</span>
<span class="sd">        # for arity == 1</span>
<span class="sd">        self._ground('str_1')</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        # for arity &gt; 1</span>
<span class="sd">        grounding = ('str_1', 'str_2', ...)</span>
<span class="sd">        self._ground(grounding)</span>
<span class="sd">        ```</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        This function can only ground one object at a time due to tuple confusion</span>
<span class="sd">        for multiple objects</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">Formula</span><span class="o">.</span><span class="n">_is_grounded</span><span class="p">(</span><span class="n">grounding</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">grounding</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grounding</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grounding</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">"expected groundings as tuple of str for num_unique_vars "</span>
                    <span class="sa">f</span><span class="s2">" &gt; 1, received </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">grounding</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">grounding</span><span class="si">}</span><span class="s2">"</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grounding</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_unique_vars</span> <span class="ow">and</span> <span class="n">arity_match</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">"expected grounding length to be of "</span>
                    <span class="sa">f</span><span class="s2">"arity </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_unique_vars</span><span class="si">}</span><span class="s2">, received </span><span class="si">{</span><span class="n">grounding</span><span class="si">}</span><span class="s2">"</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_unique_vars</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">arity_match</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> received str as grounding, expected grounding "</span>
                    <span class="sa">f</span><span class="s2">"(</span><span class="si">{</span><span class="n">grounding</span><span class="si">}</span><span class="s2">) as a tuple of len </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_unique_vars</span><span class="si">}</span><span class="s2">"</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">_Grounding</span><span class="p">(</span><span class="n">grounding</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ground_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Grounds a "Function" if given bindings that are fully bound."""</span>
        <span class="n">tmp_bindings</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">get_bindings</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">op</span><span class="p">])</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">op_id</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">):</span>

            <span class="c1"># If there are groundings and partial bindings we can still</span>
            <span class="c1">#   create new groundings by combining the partials from</span>
            <span class="c1">#   groundings and bindings. But we need the ability</span>
            <span class="c1">#   to extract partial groundings without the grounding string.</span>
            <span class="c1">#</span>
            <span class="c1">#     ```python</span>
            <span class="c1">#     bindings = [g for g in product(*tmp_bindings[op_id])]</span>
            <span class="c1">#     for g in op.groundings:  # Tuple</span>
            <span class="c1">#         for binding in bindings:</span>
            <span class="c1">#             new_g = [g[b] if binding[b] is None else binding[b]</span>
            <span class="c1">#                      for b in range(len(binding))]</span>
            <span class="c1">#             op._add_groundings(tuple(new_g))</span>
            <span class="c1">#     ```</span>

            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="kc">False</span> <span class="k">if</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">tmp_bindings</span><span class="p">[</span><span class="n">op_id</span><span class="p">]]):</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_bindings</span><span class="p">[</span><span class="n">op_id</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">op</span><span class="o">.</span><span class="n">_add_groundings</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">_ground</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">op</span><span class="o">.</span><span class="n">_add_groundings</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">_ground</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_groundings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="s2">"_Grounding"</span><span class="p">]:</span>
        <span class="sd">"""Internal usage to extract groundings as _Grounding object"""</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_has_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns True if Formula has any bindings."""</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">True</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">slot</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">slot</span><span class="p">]))</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">slot</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="k">else</span> <span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_bindings</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">))])</span>

    <span class="k">def</span> <span class="nf">_inherit_from_subformulae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">subformula</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">"Formula"</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">]):</span>
        <span class="sa">r</span><span class="sd">"""Builds the local context for a formula using subformulae.</span>

<span class="sd">        provides manual manual variable remapping if given with variables:</span>
<span class="sd">            i.e. Formula used as a function via `__call__`</span>
<span class="sd">        alternatively inherits remapping from operands if formula is not called</span>

<span class="sd">        """</span>

        <span class="c1"># inheritance variables</span>
        <span class="n">subformulae</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">_operand_vars</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">arity</span>
        <span class="n">_var_remap</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">arity</span>
        <span class="n">_bindings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_Grounding</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">arity</span>

        <span class="k">for</span> <span class="n">slot</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subformula</span><span class="p">):</span>

            <span class="c1"># variable remapping from CalledFormula:</span>
            <span class="c1">#</span>
            <span class="c1">#     ```python</span>
            <span class="c1">#     P = Predicate("P", arity=2)</span>
            <span class="c1">#     Q = Predicate("P", arity=2)</span>
            <span class="c1">#     And(P(x, y), Q(y, z))</span>
            <span class="c1">#     ```</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">subformulae</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">_operand_vars</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">_var_remap</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">_bindings</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># automatically inherit variable remapping from `uncalled` operands</span>
            <span class="c1">#   for higher level connective formulae:</span>
            <span class="c1">#</span>
            <span class="c1">#     ```python</span>
            <span class="c1">#     Implies(And(...), Or(...))</span>
            <span class="c1">#     ```</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
                    <span class="n">_operand_vars</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">unique_vars</span>
                    <span class="n">_var_remap</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">unique_vars</span>
                    <span class="n">_bindings</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">)</span>
                <span class="n">subformulae</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Formula</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>

        <span class="c1"># set class variables as read-only tuples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operand_vars</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_operand_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_remap</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_var_remap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_Grounding</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_bindings</span><span class="p">)</span>

        <span class="c1"># inherit propositional flag from children</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_propositional</span><span class="p">(</span>
                <span class="kc">False</span> <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">propositional</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">subformulae</span><span class="p">])</span> <span class="k">else</span> <span class="kc">True</span>
            <span class="p">)</span>

        <span class="c1"># remap the FOL formula if its called</span>
        <span class="c1">#</span>
        <span class="c1">#   ```python</span>
        <span class="c1">#   Implies(And(...)(u, v), Or(...)(u, v))</span>
        <span class="c1">#   ```</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_LeafFormula</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_variables</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">var_remap</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_map</span><span class="p">()</span>

        <span class="c1"># expand formula graph to include all subformulae</span>
        <span class="k">if</span> <span class="n">subformulae</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_list</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">edge</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">subformulae</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">edge_list</span><span class="p">])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_grounded</span><span class="p">(</span><span class="n">groundings</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">"_Grounding"</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns True if the grounding is given in internal "Grounded" form."""</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groundings</span><span class="p">,</span> <span class="n">_Grounding</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_unique_variables</span><span class="p">(</span><span class="o">*</span><span class="n">variables</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Combines all predicate variables into a unique tuple</span>
<span class="sd">        the tuple is sorted by the order of appearance of variables in</span>
<span class="sd">        the operands.</span>
<span class="sd">        """</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">op_vars</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">op_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Update the 'operand_map' to map parent variables to operand variables.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        `operand_map`: Tuple[Tuple[int, ...]]</span>
<span class="sd">            tells you which slots the parent variable will appear in the children variables.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operand_map</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand_vars</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">op_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_remap</span><span class="p">)):</span>
            <span class="n">op_map</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">op_var</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">op_var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_remap</span><span class="p">[</span><span class="n">op_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">op_var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operand_map</span><span class="p">[</span><span class="n">op_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">op_map</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operand_map</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">variables</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        **Notes**</span>

<span class="sd">        If the formula grounding_arity is not specified, it will be inherited</span>
<span class="sd">            from the variables. If variables are not specified, both the</span>
<span class="sd">            `grounding_arity` and variables are inherited from groundings</span>

<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span> <span class="o">=</span> <span class="n">Formula</span><span class="o">.</span><span class="n">_get_unique_variables</span><span class="p">(</span><span class="o">*</span><span class="n">variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_unique_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_contradiction_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Contradiction loss."""</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_uncertainty_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Uncertainty loss."""</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">()</span><span class="o">.</span><span class="n">logical_not</span><span class="p">()</span> <span class="o">*</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_supervised_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Supervised loss."""</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">MSELoss</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"labels"</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propositional</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">numel</span><span class="p">())</span>
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_labels</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">loss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(),</span> <span class="n">labels</span><span class="p">)</span>
        <span class="n">groundings</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groundings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">loss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="o">*</span><span class="n">groundings</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="o">*</span><span class="n">groundings</span><span class="p">))</span>

    <span class="n">increment_param_history</span> <span class="o">=</span> <span class="n">_trace</span><span class="o">.</span><span class="n">increment_param_history</span></div>


<span class="k">class</span> <span class="nc">_LeafFormula</span><span class="p">(</span><span class="n">Formula</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Specifies activation functionality as nodes instead of neurons.</span>

<span class="sd">    Assumes that all leaf formulae are propositions or predicates, therefore</span>
<span class="sd">        uses the _NodeActivation accordingly</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"propositional"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span> <span class="o">=</span> <span class="n">_NodeActivation</span><span class="p">()(</span><span class="o">**</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"activation"</span><span class="p">,</span> <span class="p">{}),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_ConnectiveFormula</span><span class="p">(</span><span class="n">Formula</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_ConnectiveNeuron</span><span class="p">(</span><span class="n">_ConnectiveFormula</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"arity"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arity</span><span class="p">)</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"propositional"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"activation"</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"negative_weights"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">negation_absorption</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span> <span class="o">=</span> <span class="n">_NeuralActivation</span><span class="p">(</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"activation"</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"type"</span><span class="p">))(</span>
            <span class="o">**</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"activation"</span><span class="p">,</span> <span class="p">{}),</span> <span class="o">**</span><span class="n">kwds</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">activation</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">Direction</span><span class="o">.</span><span class="n">UPWARD</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">activation</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">Direction</span><span class="o">.</span><span class="n">DOWNWARD</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">upward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">groundings</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Upward inference from the operands to the operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        groundings : str or tuple of str, optional</span>
<span class="sd">            restrict upward inference to a specific grounding or row in the truth table</span>
<span class="sd">        lifted : bool, optional</span>
<span class="sd">            flag that determines if lifting should be done on this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tightened_bounds : float</span>
<span class="sd">            The amount of bounds tightening or new information that is leaned by the inference step.</span>

<span class="sd">        """</span>
        <span class="c1"># Create (potentially) new groundings from functions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ground_functions</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"lifted"</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_world</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span>
                        <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">world</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span>
                        <span class="p">)[</span><span class="kc">None</span><span class="p">]</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ WORLD FREE-VARIABLE UPDATED "</span>
                    <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upward_bounds</span> <span class="o">=</span> <span class="n">_gm</span><span class="o">.</span><span class="n">upward_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">,</span> <span class="n">groundings</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">upward_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># contradiction arresting</span>
                <span class="k">return</span> <span class="mf">0.0</span>
            <span class="n">input_bounds</span><span class="p">,</span> <span class="n">groundings</span> <span class="o">=</span> <span class="n">upward_bounds</span>
            <span class="n">grounding_rows</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">None</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span>
                <span class="k">else</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">groundings</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_bounds</span><span class="p">(</span>
                <span class="n">grounding_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">input_bounds</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ BOUNDS UPDATED "</span>
                    <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">():</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ CONTRADICTION "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">downward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">groundings</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Downward inference from the operator to the operands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            restricts downward inference to an operand at the specified index. If unspecified, all operands are updated.</span>
<span class="sd">        groundings : str or tuple of str, optional</span>
<span class="sd">            restrict upward inference to a specific grounding or row in the truth table</span>
<span class="sd">        lifted : bool, optional</span>
<span class="sd">            flag that determines if lifting should be done on this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tightened_bounds : float</span>
<span class="sd">            The amount of bounds tightening or new information that is leaned by the inference step.</span>

<span class="sd">        """</span>
        <span class="c1"># Create (potentially) new groundings from functions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ground_functions</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"lifted"</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">new_worlds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_inv</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">)[</span><span class="kc">None</span><span class="p">],</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">world</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span>
                    <span class="kc">None</span>
                <span class="p">],</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">op_idx</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">):</span>
                <span class="n">op_aggregate</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_world</span><span class="p">(</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="n">new_worlds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">op_idx</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">op_aggregate</span>
                <span class="k">if</span> <span class="n">op_aggregate</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s2">"↓ WORLD FREE-VARIABLE UPDATED "</span>
                        <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">op_aggregate</span><span class="si">}</span><span class="s2"> "</span>
                        <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                        <span class="sa">f</span><span class="s2">"FROM:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                        <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                        <span class="sa">f</span><span class="s2">"PARENT:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">downward_bounds</span> <span class="o">=</span> <span class="n">_gm</span><span class="o">.</span><span class="n">downward_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">,</span> <span class="n">groundings</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">downward_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># contradiction arresting</span>
                <span class="k">return</span> <span class="mf">0.0</span>
            <span class="n">out_bounds</span><span class="p">,</span> <span class="n">input_bounds</span><span class="p">,</span> <span class="n">groundings</span> <span class="o">=</span> <span class="n">downward_bounds</span>
            <span class="n">new_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_inv</span><span class="p">(</span><span class="n">out_bounds</span><span class="p">,</span> <span class="n">input_bounds</span><span class="p">)</span>
            <span class="n">op_indices</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="p">([(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">index</span><span class="p">])])</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">op_index</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">op_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
                    <span class="n">op_grounding_rows</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">groundings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">op_grounding_rows</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">op_grounding_rows</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">groundings</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">g_i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">groundings</span><span class="p">):</span>
                            <span class="n">op_g</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">partial_grounding</span><span class="p">[</span><span class="n">slot</span><span class="p">])</span>
                                <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand_map</span><span class="p">[</span><span class="n">op_index</span><span class="p">]</span>
                            <span class="p">]</span>
                            <span class="n">op_g</span> <span class="o">=</span> <span class="n">_Grounding</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">op_g</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op_g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">op_g</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">op_grounding_rows</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op_g</span><span class="p">)</span>
                <span class="n">op_aggregate</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_bounds</span><span class="p">(</span>
                    <span class="n">op_grounding_rows</span><span class="p">,</span> <span class="n">new_bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">op_index</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">op_aggregate</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s2">"↓ BOUNDS UPDATED "</span>
                        <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">op_aggregate</span><span class="si">}</span><span class="s2"> "</span>
                        <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                        <span class="sa">f</span><span class="s2">"FROM:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                        <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                        <span class="sa">f</span><span class="s2">"PARENT:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">():</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s2">"↓ CONTRADICTION "</span>
                        <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                        <span class="sa">f</span><span class="s2">"FROM:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                        <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                        <span class="sa">f</span><span class="s2">"PARENT:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">op_aggregate</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_logical_loss</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">slacks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Logical loss to create a loss on logical constraint violation.</span>

<span class="sd">        Assumes a soft logic computation and calculates the loss on constraints</span>
<span class="sd">        as defined in [equations 86-89](https://arxiv.org/pdf/2006.13155.pdf)</span>
<span class="sd">        when slacks are given, the constraints are allowed to be violated</span>
<span class="sd">        however this affects the neuron interpretability and should only be</span>
<span class="sd">        used if the model is not strictly required to obey a classical</span>
<span class="sd">        definition of logic</span>

<span class="sd">        """</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">alpha</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">bias</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">weights</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">a</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">coeff</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">And</span><span class="p">):</span>
            <span class="n">TRUE</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">FALSE</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">F</span><span class="p">))</span>
            <span class="n">true_hinge</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">TRUE</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">-</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">TRUE</span> <span class="o">*</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">false_hinge</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FALSE</span> <span class="o">&gt;</span> <span class="n">F</span><span class="p">,</span> <span class="n">FALSE</span> <span class="o">-</span> <span class="n">F</span><span class="p">,</span> <span class="n">FALSE</span> <span class="o">*</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">slacks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">slacks</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">slacks_false</span> <span class="o">=</span> <span class="n">false_hinge</span> <span class="o">*</span> <span class="p">(</span><span class="n">false_hinge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">slacks_true</span> <span class="o">=</span> <span class="n">true_hinge</span> <span class="o">*</span> <span class="p">(</span><span class="n">true_hinge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">false_hinge</span> <span class="o">-=</span> <span class="n">slacks_false</span>
                    <span class="n">true_hinge</span> <span class="o">-=</span> <span class="n">slacks_true</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">slacks</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">slacks_true</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span>
                        <span class="n">slacks_false</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">false_hinge</span> <span class="o">-=</span> <span class="n">slacks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">feasibility</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">true_hinge</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span>
                <span class="n">false_hinge</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Or</span><span class="p">):</span>
            <span class="n">TRUE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
            <span class="n">FALSE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">true_hinge</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">TRUE</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">-</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">TRUE</span> <span class="o">*</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">false_hinge</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FALSE</span> <span class="o">&gt;</span> <span class="n">F</span><span class="p">,</span> <span class="n">FALSE</span> <span class="o">-</span> <span class="n">F</span><span class="p">,</span> <span class="n">FALSE</span> <span class="o">*</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Implies</span><span class="p">):</span>
            <span class="n">TRUE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>  <span class="c1"># T = 1-F for x and T for y</span>
            <span class="n">FALSE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span>
            <span class="n">true_hinge</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">TRUE</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">-</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">TRUE</span> <span class="o">*</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">false_hinge</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FALSE</span> <span class="o">&gt;</span> <span class="n">F</span><span class="p">,</span> <span class="n">FALSE</span> <span class="o">-</span> <span class="n">F</span><span class="p">,</span> <span class="n">FALSE</span> <span class="o">*</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">true_hinge</span><span class="o">.</span><span class="n">square</span><span class="p">()</span> <span class="o">+</span> <span class="n">false_hinge</span><span class="o">.</span><span class="n">square</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">neural_equivalence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">neuron</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">bias</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">bias</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">weights</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">_NAryNeuron</span><span class="p">(</span><span class="n">_ConnectiveNeuron</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""N-ary connective neuron."""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">formula</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_BinaryNeuron</span><span class="p">(</span><span class="n">_ConnectiveNeuron</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Restrict neurons to 2 inputs."""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">"Binary neurons expect 2 formulae as inputs, received "</span>
                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_UnaryOperator</span><span class="p">(</span><span class="n">_ConnectiveFormula</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Restrict operators to 1 input."""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">"Unary operator expect 1 formula as input, received "</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_Quantifier</span><span class="p">(</span><span class="n">_UnaryOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Symbolic container for quantifiers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    kwds : dict</span>
<span class="sd">        fully_grounded : bool</span>
<span class="sd">            specifies if a full upward inference can be done on a</span>
<span class="sd">            quantifier due to all the groundings being present inside it.</span>
<span class="sd">            This applies to the lower bound of a `ForAll` and upper bound</span>
<span class="sd">            of an `Exists`</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fully_grounded : bool</span>
<span class="sd">    unique_var_slots : tuple of int</span>
<span class="sd">        returns the slot index of each unique variable</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantified_variable</span><span class="p">:</span> <span class="s2">"Variable"</span><span class="p">,</span> <span class="n">formula</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantified_variable</span> <span class="o">=</span> <span class="n">quantified_variable</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fully_grounded</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"fully_grounded"</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grounding_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_activation</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expanded_unique_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_unique_variables_overlap</span><span class="p">(</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">destination</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">"""combines all predicate variables into a unique tuple</span>
<span class="sd">        the tuple is sorted by the order of appearance of variables in</span>
<span class="sd">        the operands</span>
<span class="sd">        """</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dst_var</span> <span class="ow">in</span> <span class="n">destination</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dst_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dst_var</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">upward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Upward inference from the operands to the operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lifted : bool, optional</span>
<span class="sd">            flag that determines if lifting should be done on this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tightened_bounds : float</span>
<span class="sd">            The amount of bounds tightening or new information that is leaned by the inference step.</span>

<span class="sd">        """</span>

        <span class="c1"># Create (potentially) new groundings from functions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ground_functions</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"lifted"</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_world</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">world</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">reset_world</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ WORLD FREE-VARIABLE UPDATED "</span>
                    <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_groundings</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grounding_set</span><span class="p">)</span>
            <span class="n">input_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_upward_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">input_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grounding_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_groundings</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_activation</span><span class="p">(</span><span class="n">world</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_bounds</span><span class="p">(</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">input_bounds</span><span class="o">.</span><span class="n">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span>
                <span class="n">bound</span><span class="o">=</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">Bound</span><span class="o">.</span><span class="n">UPPER</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ForAll</span><span class="p">)</span> <span class="k">else</span> <span class="n">Bound</span><span class="o">.</span><span class="n">LOWER</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fully_grounded</span>
                    <span class="k">else</span> <span class="kc">None</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ BOUNDS UPDATED "</span>
                    <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">():</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ CONTRADICTION "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_set_activation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">"""Updates the neural activation according to grounding dimension size</span>

<span class="sd">        The computation of a quantifier is implemented via one of the weighed</span>
<span class="sd">            neurons, And/Or for ForAll/Exists.</span>
<span class="sd">        At present, weighted quantifiers have not been well studied and is</span>
<span class="sd">            therefore turned off</span>
<span class="sd">        However the dimension of computation is different, computing over the</span>
<span class="sd">            groundings of the input formula instead of multiple formulae, since</span>
<span class="sd">            there can only be one formula to quantify over.</span>
<span class="sd">        The activation is therefore required to grow according to number of</span>
<span class="sd">            groundings present in the formula, which can grow as groundings</span>
<span class="sd">            propagate via inference.</span>

<span class="sd">        """</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">"And"</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ForAll</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">(</span><span class="s2">"Or"</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Exists</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"arity"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grounding_set</span><span class="p">))</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"propositional"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span> <span class="o">=</span> <span class="n">_NeuralActivation</span><span class="p">()(</span>
            <span class="n">activation</span><span class="o">=</span><span class="p">{</span><span class="s2">"weights_learning"</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span> <span class="o">**</span><span class="n">kwds</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">activation</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">Direction</span><span class="o">.</span><span class="n">UPWARD</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_has_free_variables</span><span class="p">(</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">operand</span><span class="p">:</span> <span class="n">Formula</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns True if the quantifier contains free variables."""</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">variables</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">({</span><span class="o">*</span><span class="n">operand</span><span class="o">.</span><span class="n">unique_vars</span><span class="p">})</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">true_groundings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]:</span>
        <span class="sa">r</span><span class="sd">"""Returns a set of groundings that are True."""</span>
        <span class="n">valid_groundings</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grounding_set</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Fact</span><span class="o">.</span><span class="n">TRUE</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groundings</span><span class="p">(</span><span class="n">valid_groundings</span><span class="p">)</span> <span class="k">if</span> <span class="n">valid_groundings</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_upward_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">:</span> <span class="n">Formula</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Set Quantifier grounding table and return operand tensor."""</span>
        <span class="n">operand_grounding_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">grounding_table</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand_grounding_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_grounding_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">grounding</span>
                <span class="k">for</span> <span class="n">grounding</span> <span class="ow">in</span> <span class="n">operand_grounding_set</span>
                <span class="k">if</span> <span class="n">_gm</span><span class="o">.</span><span class="n">is_grounding_in_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grounding</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">operand</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_grounding_set</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grounding_set</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_groundings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groundings</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]:</span>
        <span class="sd">"""Internal usage to extract groundings as _Grounding object"""</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_Grounding</span><span class="o">.</span><span class="n">eval</span><span class="p">,</span> <span class="n">groundings</span><span class="p">))</span> <span class="k">if</span> <span class="n">groundings</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">groundings</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">groundings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]:</span>
        <span class="sa">r</span><span class="sd">"""returns a set of groundings as str or tuple of str"""</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_Grounding</span><span class="o">.</span><span class="n">eval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grounding_set</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">add_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Fact</span><span class="p">,</span> <span class="n">Set</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">facts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_activation</span><span class="p">(</span><span class="n">world</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_NAryOperator</span><span class="p">(</span><span class="n">_ConnectiveFormula</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""N-ary connective operator"""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">formula</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_Grounding</span><span class="p">(</span><span class="n">_utils</span><span class="o">.</span><span class="n">MultiInstance</span><span class="p">,</span> <span class="n">_utils</span><span class="o">.</span><span class="n">UniqueNameAssumption</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Propositionalises constants for first-order logic</span>

<span class="sd">    Returns a container for a string or a tuple of strings.</span>
<span class="sd">    Follows the unique name assumption so that given constant(s) return the</span>
<span class="sd">        same object</span>
<span class="sd">    Decomposes multiple constants (from the tuple) by storing each str as a</span>
<span class="sd">        separate grounding object but returns only the compound container.</span>
<span class="sd">        This decomposition is used in grounding management to ensure that all</span>
<span class="sd">        partial strings also follow the unique name assumption by returning the</span>
<span class="sd">        same container</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    constants : str or tuple of str</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    _Grounding('person1')</span>
<span class="sd">    _Grounding(('person1', 'date1'))</span>
<span class="sd">    ```</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        conversion of 'constants' param to str form</span>
<span class="sd">    grounding_arity : int</span>
<span class="sd">        length of the 'constants' param</span>
<span class="sd">    partial_grounding : tuple(_Grounding)</span>
<span class="sd">        tuple of groundings for decomposition when constants given as tuple</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constants</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">constants</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grounding_arity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constants</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partial_grounding</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_partial_grounding_from_str</span><span class="p">,</span> <span class="n">constants</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grounding_arity</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partial_grounding</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_partial_grounding_from_str</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">constant</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"_Grounding"</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns partial Grounding given grounding str"""</span>
        <span class="k">return</span> <span class="n">_Grounding</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="n">constant</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">ground_by_groundings</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">grounding</span><span class="p">:</span> <span class="s2">"_Grounding"</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Reduce a tuple of groundings to a single grounding"""</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">grounding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grounding</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">else</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grounding</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns the length of the grounding arity"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grounding_arity</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns the name of the grounding"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">grounding</span><span class="p">:</span> <span class="s2">"_Grounding"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
        <span class="sa">r</span><span class="sd">"""Returns the original constant(s) in str or tuple of str form"""</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">grounding</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">grounding</span><span class="o">.</span><span class="n">grounding_arity</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">grounding</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span> <span class="nc">_NodeActivation</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s2">"lnn.neural.activations.node"</span><span class="p">),</span>
            <span class="s2">"_NodeActivation"</span><span class="p">,</span>
        <span class="p">)(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_NeuralActivation</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">"""Switch class, to choose a method from the correct activation class"""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron_type</span> <span class="o">=</span> <span class="nb">type</span> <span class="k">if</span> <span class="nb">type</span> <span class="k">else</span> <span class="n">NeuralActivation</span><span class="o">.</span><span class="n">LukasiewiczTransparent</span>
        <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssertNeuronActivationType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">"lnn.neural.methods.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_type</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_type</span><span class="o">.</span><span class="n">name</span><span class="p">)(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="c1">##</span>
<span class="c1"># Public Classes</span>
<span class="c1">#</span>
<span class="c1"># All classes below should be exposed via the public API</span>
<span class="c1"># The formulas are ordered alphabetically according to the API docs in</span>
<span class="c1"># https://ibm.github.io/LNN/lnn/LNN.html</span>
<span class="c1">##</span>


<div class="viewcode-block" id="Predicate"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Predicate">[docs]</a><span class="k">class</span> <span class="nc">Predicate</span><span class="p">(</span><span class="n">_LeafFormula</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Creates a container for a predicate</span>

<span class="sd">    Stores a table of truths, with columns specified by the arity and rows</span>
<span class="sd">        indexed by the grounding</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        name of the predicate</span>
<span class="sd">    arity : int, optional</span>
<span class="sd">        If unspecified, assumes a unary predicate</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    P1 = Predicate('P1')</span>
<span class="sd">    P2 = Predicate('P2', arity=2)</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">arity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"arity expected as int &gt; 0, received </span><span class="si">{</span><span class="n">arity</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="n">arity</span><span class="p">,</span> <span class="n">propositional</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_variables</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">"?</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arity</span><span class="p">)))</span>

<div class="viewcode-block" id="Predicate.add_data"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Predicate.add_data">[docs]</a>    <span class="k">def</span> <span class="nf">add_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">set</span><span class="p">]):</span>
        <span class="sa">r</span><span class="sd">"""Populate predicate with facts</span>

<span class="sd">        Facts required in dict or set</span>
<span class="sd">            - dict for grounding-based facts</span>
<span class="sd">            - set for broadcasting facts across all groundings</span>
<span class="sd">              requires a set of 1 item</span>
<span class="sd">        dict keys for groundings and values as facts</span>
<span class="sd">        tuple facts required in bounds form `(Lower, Upper)`</span>

<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">facts</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""A called first-order logic predicate</span>

<span class="sd">        This correctly instantiates a predicate with variables - which is required when</span>
<span class="sd">        using the predicate in a compound formula. Calling the predicate allows the LNN</span>
<span class="sd">        to construct the inheritance tree from subformulae.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ```python</span>
<span class="sd">        P, Q = Predicates('P', 'Q')</span>
<span class="sd">        x, y = Variables('x', 'y')</span>
<span class="sd">        And(P(x), Q(y))  # calling both predicates</span>
<span class="sd">        ```</span>
<span class="sd">        Here the conjunction inherits its variables from all subformulae, treating it as</span>
<span class="sd">        an ordered unique collection (list).</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>


<div class="viewcode-block" id="Predicates"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Predicates">[docs]</a><span class="k">def</span> <span class="nf">Predicates</span><span class="p">(</span><span class="o">*</span><span class="n">predicates</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Instantiates multiple predicates.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    P1, P2 = Predicates("P1", "P2", arity=2)</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">return1</span><span class="p">([</span><span class="n">Predicate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predicates</span><span class="p">])</span></div>


<div class="viewcode-block" id="Proposition"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Proposition">[docs]</a><span class="k">class</span> <span class="nc">Proposition</span><span class="p">(</span><span class="n">_LeafFormula</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Creates propositional containers</span>

<span class="sd">    Stores and retrieves single truth bounds instead of tables as in FOL case</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        name of the proposition</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    P = Proposition('Person')</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">propositional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

<div class="viewcode-block" id="Proposition.add_data"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Proposition.add_data">[docs]</a>    <span class="k">def</span> <span class="nf">add_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fact</span><span class="p">:</span> <span class="n">Fact</span><span class="p">):</span>
        <span class="sd">"""Populate proposition with facts</span>

<span class="sd">        Facts required in bool, tuple or None</span>
<span class="sd">        None fact assumes `Unknown`</span>
<span class="sd">        tuple fact required in bounds form `(Lower, Upper)`</span>

<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">fact</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Propositions"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Propositions">[docs]</a><span class="k">def</span> <span class="nf">Propositions</span><span class="p">(</span><span class="o">*</span><span class="n">propositions</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Instantiates multiple propositions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    P1, P2 = Propositions("P1", "P2")</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">return1</span><span class="p">([</span><span class="n">Proposition</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">propositions</span><span class="p">])</span></div>


<div class="viewcode-block" id="Variable"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Variable">[docs]</a><span class="k">class</span> <span class="nc">Variable</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">"""Free variables to quantify first-order logic formulae</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    name : str</span>
<span class="sd">        name of the free variable</span>
<span class="sd">    type : str, optional</span>
<span class="sd">        constant of the type associated with the free variable</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    x = Variable('x', 'person')</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Returns the name of the free variable"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<div class="viewcode-block" id="Variables"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Variables">[docs]</a><span class="k">def</span> <span class="nf">Variables</span><span class="p">(</span><span class="o">*</span><span class="n">variables</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Variable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Variable</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
    <span class="sd">"""Instantiates multiple variables.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    x, y = Variables("x", "y")</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">return1</span><span class="p">([</span><span class="n">Variable</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">])</span></div>


<div class="viewcode-block" id="And"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.And">[docs]</a><span class="k">class</span> <span class="nc">And</span><span class="p">(</span><span class="n">_NAryNeuron</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Symbolic n-ary [conjunction](https://en.wikipedia.org/wiki/Logical_conjunction).</span>

<span class="sd">    Returns a logical conjunction where inputs can be [propositions](LNN.html#lnn.Proposition), `called` first-order logic [predicates](LNN.html#lnn.Predicate) or any other [connective formulae](LNN.html#symbolic-structure).</span>
<span class="sd">    Propositional inputs yield a propositional node, whereas if any input is a predicate it will cause the connective to increase its dimension to also be a FOL node (i.e. stores a table of facts).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ``*formula`` : Formula</span>
<span class="sd">        A variable length argument list that accepts any number of input formulae objects as arguments.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        A custom name for the node to be used for identification and custom printing. If unspecified, defaults the structure of the node.</span>
<span class="sd">    activation : dict, optional</span>
<span class="sd">        Parameters given as a dictionary of configuration options, see the [neural configuration](../usage.html#neural-configuration) for more details</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    # Propositional</span>
<span class="sd">    A, B, C = Propositions('A', 'B', 'C')</span>
<span class="sd">    And(A, B, C)</span>
<span class="sd">    ```</span>
<span class="sd">    ```python</span>
<span class="sd">    # First-order logic</span>
<span class="sd">    x, y = Variables('x', 'y')</span>
<span class="sd">    A, C = Predicates('A', 'C')</span>
<span class="sd">    B = Predicate('B', arity=2)</span>
<span class="sd">    And(A(x), B(x, y), C(y)))</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"activation"</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_operator_str</span><span class="p">(</span>
            <span class="n">kwds</span><span class="p">[</span><span class="s2">"activation"</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"type"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_operator_str</span><span class="p">(</span><span class="nb">type</span><span class="p">:</span> <span class="n">NeuralActivation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">type</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">∧"</span> <span class="k">if</span> <span class="nb">type</span> <span class="k">else</span> <span class="s2">"∧"</span></div>


<div class="viewcode-block" id="Or"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Or">[docs]</a><span class="k">class</span> <span class="nc">Or</span><span class="p">(</span><span class="n">_NAryNeuron</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Symbolic n-ary [disjunction](https://en.wikipedia.org/wiki/Logical_disjunction).</span>

<span class="sd">    Returns a logical disjunction where inputs can be [propositions](LNN.html#lnn.Proposition), `called` first-order logic [predicates](LNN.html#lnn.Predicate) or any other [connective formulae](LNN.html#symbolic-structure).</span>
<span class="sd">    Propositional inputs yield a propositional node, whereas if any input is a predicate it will cause the connective to increase its dimension to also be a FOL node (i.e. stores a table of facts).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ``*formula`` : Formula</span>
<span class="sd">        A variable length argument list that accepts any number of input formulae objects as arguments.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        A custom name for the node to be used for identification and custom printing. If unspecified, defaults the structure of the node.</span>
<span class="sd">    activation : dict, optional</span>
<span class="sd">        Parameters given as a dictionary of configuration options, see the [neural configuration](../usage.html#neural-configuration) for more details</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    # Propositional</span>
<span class="sd">    A, B, C = Propositions('A', 'B', 'C')</span>
<span class="sd">    Or(A, B, C)</span>
<span class="sd">    ```</span>
<span class="sd">    ```python</span>
<span class="sd">    # First-order logic</span>
<span class="sd">    x, y = Variables('x', 'y')</span>
<span class="sd">    A, C = Predicates('A', 'C')</span>
<span class="sd">    B = Predicate('B', arity=2)</span>
<span class="sd">    Or(A(x), B(x, y), C(y)))</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"activation"</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_operator_str</span><span class="p">(</span>
            <span class="n">kwds</span><span class="p">[</span><span class="s2">"activation"</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"type"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_operator_str</span><span class="p">(</span><span class="nb">type</span><span class="p">:</span> <span class="n">NeuralActivation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">type</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">∨"</span> <span class="k">if</span> <span class="nb">type</span> <span class="k">else</span> <span class="s2">"∨"</span></div>


<div class="viewcode-block" id="Implies"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Implies">[docs]</a><span class="k">class</span> <span class="nc">Implies</span><span class="p">(</span><span class="n">_BinaryNeuron</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Symbolic binary [implication](https://en.wikipedia.org/wiki/Logical_implication).</span>

<span class="sd">    Returns a logical implication node where inputs can be [propositions](LNN.html#lnn.Proposition), `called` first-order logic [predicates](LNN.html#lnn.Predicate) or any other [connective formulae](LNN.html#symbolic-structure).</span>
<span class="sd">    Propositional inputs yield a propositional node, whereas if any input is a predicate it will cause the connective to increase its dimension to also be a FOL node (i.e. stores a table of facts).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : Formula</span>
<span class="sd">        The left-hand side formula of the binary inputs to the connective.</span>
<span class="sd">    rhs : Formula</span>
<span class="sd">        The right-hand side formula of the binary inputs to the connective.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        A custom name for the node to be used for identification and custom printing. If unspecified, defaults the structure of the node.</span>
<span class="sd">    activation : dict, optional</span>
<span class="sd">        Parameters given as a dictionary of configuration options, see the [neural configuration](../usage.html#neural-configuration) for more details</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    # Propositional</span>
<span class="sd">    A, B = Propositions('A', 'B')</span>
<span class="sd">    Implies(A, B)</span>
<span class="sd">    ```</span>
<span class="sd">    ```python</span>
<span class="sd">    # First-order logic</span>
<span class="sd">    x, y = Variables('x', 'y')</span>
<span class="sd">    A = Predicate('A')</span>
<span class="sd">    B = Predicate('B', arity=2)</span>
<span class="sd">    Implies(A(x), B(x, y)))</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span> <span class="o">=</span> <span class="s2">"→"</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"activation"</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">kwds</span><span class="p">[</span><span class="s2">"activation"</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"bias_learning"</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_operator_str</span><span class="p">(</span>
            <span class="n">kwds</span><span class="p">[</span><span class="s2">"activation"</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"type"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_operator_str</span><span class="p">(</span><span class="nb">type</span><span class="p">:</span> <span class="n">NeuralActivation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># if type is NeuralActivation.Product:</span>
        <span class="c1">#     return "|"</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">type</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">→"</span> <span class="k">if</span> <span class="nb">type</span> <span class="k">else</span> <span class="s2">"→"</span></div>


<div class="viewcode-block" id="Not"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Not">[docs]</a><span class="k">class</span> <span class="nc">Not</span><span class="p">(</span><span class="n">_UnaryOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Symbolic Negation</span>

<span class="sd">    Returns a logical negation where inputs can be propositional,</span>
<span class="sd">    first-order logic predicates or other connectives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    formula : Formula</span>
<span class="sd">        accepts a unary input Formula</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    # Propositional</span>
<span class="sd">    A = Proposition('A')</span>
<span class="sd">    Not(A)</span>
<span class="sd">    ```</span>
<span class="sd">    ```python</span>
<span class="sd">    # First-order logic</span>
<span class="sd">    x, y = Variables('x', 'y')</span>
<span class="sd">    A = Predicate('A', arity=2)</span>
<span class="sd">    Not(A(x, y)))</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span> <span class="o">=</span> <span class="s2">"¬"</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"propositional"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span> <span class="o">=</span> <span class="n">_NodeActivation</span><span class="p">()(</span><span class="o">**</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"activation"</span><span class="p">,</span> <span class="p">{}),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

<div class="viewcode-block" id="Not.upward"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Not.upward">[docs]</a>    <span class="k">def</span> <span class="nf">upward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Upward inference from the operands to the operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lifted : bool, optional</span>
<span class="sd">            flag that determines if lifting should be done on this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tightened_bounds : float</span>
<span class="sd">            The amount of bounds tightening or new information that is leaned by the inference step.</span>

<span class="sd">        """</span>

        <span class="c1"># Create (potentially) new groundings from functions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ground_functions</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"lifted"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_world</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">_utils</span><span class="o">.</span><span class="n">negate_bounds</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">world</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
                <span class="n">groundings</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">groundings</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_groundings</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_groundings</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_bounds</span><span class="p">(</span>
                <span class="kc">None</span><span class="p">,</span> <span class="n">_utils</span><span class="o">.</span><span class="n">negate_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="o">*</span><span class="n">groundings</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">():</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ CONTRADICTION "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">bounds</span></div>

<div class="viewcode-block" id="Not.downward"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Not.downward">[docs]</a>    <span class="k">def</span> <span class="nf">downward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Downward inference from the operator to the operands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lifted : bool, optional</span>
<span class="sd">            flag that determines if lifting should be done on this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tightened_bounds : float</span>
<span class="sd">            The amount of bounds tightening or new information that is leaned by the inference step.</span>

<span class="sd">        """</span>
        <span class="c1"># Create (potentially) new groundings from functions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ground_functions</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"lifted"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_world</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">_utils</span><span class="o">.</span><span class="n">negate_bounds</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
                <span class="n">groundings</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">groundings</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_groundings</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_groundings</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_add_groundings</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_bounds</span><span class="p">(</span>
                <span class="kc">None</span><span class="p">,</span> <span class="n">_utils</span><span class="o">.</span><span class="n">negate_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="o">*</span><span class="n">groundings</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">():</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↓ CONTRADICTION "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FROM:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"PARENT:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">bounds</span></div></div>


<div class="viewcode-block" id="Equivalent"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Equivalent">[docs]</a><span class="k">class</span> <span class="nc">Equivalent</span><span class="p">(</span><span class="n">_BinaryNeuron</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Symbolic Equivalence - a bidirectional binary implication or IFF (if and only if) node.</span>

<span class="sd">    Returns a logical bidirectional equivalence node where inputs can be [propositions](LNN.html#lnn.Proposition),</span>
<span class="sd">    `called` first-order logic [predicates](LNN.html#lnn.Predicate) or any other [connective formulae](LNN.html#symbolic-structure).</span>
<span class="sd">    Propositional inputs yield a propositional node, whereas if any input is a predicate it will cause the connective to increase its dimension to also be a FOL node (i.e. stores a table of facts).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : Formula</span>
<span class="sd">        The left-hand side formula of the binary inputs to the connective.</span>
<span class="sd">    rhs : Formula</span>
<span class="sd">        The right-hand side formula of the binary inputs to the connective.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        A custom name for the node to be used for identification and custom printing. If unspecified, defaults the structure of the node.</span>
<span class="sd">    activation : dict, optional</span>
<span class="sd">        parameters given as a dictionary of configuration options, see the [neural configuration](../usage.html#neural-configuration) for more details</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    # Propositional</span>
<span class="sd">    A, B = Propositions('A', 'B')</span>
<span class="sd">    Equivalent(A, B)</span>
<span class="sd">    ```</span>
<span class="sd">    ```python</span>
<span class="sd">    # First-order logic</span>
<span class="sd">    x, y = Variables('x', 'y')</span>
<span class="sd">    A = Predicate('A')</span>
<span class="sd">    B = Predicate('B', arity=2)</span>
<span class="sd">    Equivalent(A(x), B(x, y)))</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span> <span class="o">=</span> <span class="s2">"∧"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Imp1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imp2</span> <span class="o">=</span> <span class="n">Implies</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">),</span> <span class="n">Implies</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Imp1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imp2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">activation</span><span class="p">(</span><span class="s2">"And"</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">Direction</span><span class="o">.</span><span class="n">UPWARD</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">activation</span><span class="p">(</span><span class="s2">"And"</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">Direction</span><span class="o">.</span><span class="n">DOWNWARD</span><span class="p">)</span>

<div class="viewcode-block" id="Equivalent.upward"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Equivalent.upward">[docs]</a>    <span class="k">def</span> <span class="nf">upward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">groundings</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Upward inference from the operands to the operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        groundings : str or tuple of str</span>
<span class="sd">            restrict upward inference to a specific grounding or row in the truth table</span>
<span class="sd">        lifted : bool, optional</span>
<span class="sd">            flag that determines if lifting should be done on this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tightened_bounds : float</span>
<span class="sd">            The amount of bounds tightening or new information that is leaned by the inference step.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Imp1</span><span class="o">.</span><span class="n">upward</span><span class="p">(</span><span class="n">groundings</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Imp2</span><span class="o">.</span><span class="n">upward</span><span class="p">(</span><span class="n">groundings</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">upward</span><span class="p">(</span><span class="n">groundings</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Equivalent.downward"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Equivalent.downward">[docs]</a>    <span class="k">def</span> <span class="nf">downward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">groundings</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Downward inference from the operator to the operands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            restricts downward inference to an operand at the specified index. If unspecified, all operands are updated.</span>
<span class="sd">        groundings : str or tuple of str, optional</span>
<span class="sd">            restrict upward inference to a specific grounding or row in the truth table</span>
<span class="sd">        lifted : bool, optional</span>
<span class="sd">            flag that determines if lifting should be done on this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tightened_bounds : float</span>
<span class="sd">            The amount of bounds tightening or new information that is leaned by the inference step.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Imp1</span><span class="o">.</span><span class="n">downward</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">groundings</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Imp2</span><span class="o">.</span><span class="n">downward</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">groundings</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">downward</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">groundings</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Exists"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Exists">[docs]</a><span class="k">class</span> <span class="nc">Exists</span><span class="p">(</span><span class="n">_Quantifier</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Symbolic existential quantifier.</span>

<span class="sd">    When working with belief bounds - existential operators restrict upward inference to only work with the given formula's lower bound. Downward inference behaves as usual.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ``*variables`` : Variable</span>
<span class="sd">    formula : Formula</span>
<span class="sd">        The FOL formula to quantify over, may be a connective formula or a Predicate.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    No free variables, quantifies over all of the variables in the formula.</span>
<span class="sd">    ```python</span>
<span class="sd">    Some_1 = Exists(birthdate(p, d)))</span>
<span class="sd">    Some_2 = Exists(p, d, birthdate(p, d)))</span>
<span class="sd">    ```</span>

<span class="sd">    Free variables, quantifies over a subset of variables in the formula.</span>
<span class="sd">    ```python</span>
<span class="sd">    Some = Exists(p, birthdate(p, d)))</span>
<span class="sd">    ```</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    Quantifier with free variables, not yet implemented. It is required that we quantify over all the variables given in the formula, either by specifying all the variables or but not specifying any variables - which is equivalent to quantifying over all variables.</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span> <span class="o">=</span> <span class="s2">"∃"</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>


<div class="viewcode-block" id="ForAll"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.ForAll">[docs]</a><span class="k">class</span> <span class="nc">ForAll</span><span class="p">(</span><span class="n">_Quantifier</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Symbolic universal quantifier.</span>

<span class="sd">    When working with belief bounds - universal operators restrict upward inference to only work with the given formula's upper bound. Downward inference behaves as usual.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ``*variables`` : Variable</span>
<span class="sd">    formula : Formula</span>
<span class="sd">        The FOL formula to quantify over, may be a connective formula or a Predicate.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    No free variables, quantifies over all of the variables in the formula.</span>
<span class="sd">    ```python</span>
<span class="sd">    All_1 = ForAll(birthdate(p, d)))</span>
<span class="sd">    All_2 = ForAll(p, d, birthdate(p, d)))</span>
<span class="sd">    ```</span>

<span class="sd">    Free variables, quantifies over a subset of variables in the formula.</span>
<span class="sd">    ```python</span>
<span class="sd">    All = ForAll(p, birthdate(p, d)))</span>
<span class="sd">    ```</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    Quantifier with free variables, not yet implemented. It is required that we quantify over all the variables given in the formula, either by specifying all the variables or but not specifying any variables - which is equivalent to quantifying over all variables.</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span> <span class="o">=</span> <span class="s2">"∀"</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"world"</span><span class="p">,</span> <span class="n">World</span><span class="o">.</span><span class="n">AXIOM</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

<div class="viewcode-block" id="ForAll.downward"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.ForAll.downward">[docs]</a>    <span class="k">def</span> <span class="nf">downward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Downward inference from the operator to the operands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lifted : bool, optional</span>
<span class="sd">            flag that determines if lifting should be done on this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tightened_bounds : float</span>
<span class="sd">            The amount of bounds tightening or new information that is leaned by the inference step.</span>

<span class="sd">        """</span>
        <span class="c1"># Create (potentially) new groundings from functions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ground_functions</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"lifted"</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_world</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↓ WORLD FREE-VARIABLE UPDATED "</span>
                    <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FROM:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"PARENT:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grounding_set</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">operand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">current_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
            <span class="n">groundings</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_bounds</span><span class="p">(</span>
                <span class="p">[</span><span class="n">operand</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span><span class="p">],</span> <span class="n">current_bounds</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↓ BOUNDS UPDATED "</span>
                    <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FROM:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"PARENT:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">operand</span><span class="o">.</span><span class="n">is_contradiction</span><span class="p">():</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↓ CONTRADICTION "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="n">operand</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FROM:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="n">operand</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"PARENT:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div></div>


<div class="viewcode-block" id="Congruent"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Congruent">[docs]</a><span class="k">class</span> <span class="nc">Congruent</span><span class="p">(</span><span class="n">_NAryOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Symbolic Congruency</span>

<span class="sd">    This is used to define nodes that are symbolically equivalent to one another</span>
<span class="sd">    (despite the possibility of neural differences)</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formulae</span><span class="p">:</span> <span class="n">Formula</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_str</span> <span class="o">=</span> <span class="s2">"≅"</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">formulae</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">"propositional"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span> <span class="o">=</span> <span class="n">_NodeActivation</span><span class="p">()(</span><span class="o">**</span><span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"activation"</span><span class="p">,</span> <span class="p">{}),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">congruent_nodes</span> <span class="k">else</span> <span class="kc">False</span>

<div class="viewcode-block" id="Congruent.add_data"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Congruent.add_data">[docs]</a>    <span class="k">def</span> <span class="nf">add_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Fact</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]):</span>
        <span class="sd">"""Should not be called by the user"""</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">"Should not be called directly by the user, instead use "</span>
            <span class="s2">"`congruent_node.upward()` to evaluate the facts from the operands"</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">upward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">groundings</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Upward inference from the operands to the operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        groundings : str or tuple of str</span>
<span class="sd">            restrict upward inference to a specific grounding or row in the truth table</span>
<span class="sd">        lifted : bool, optional</span>
<span class="sd">            flag that determines if lifting should be done on this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tightened_bounds : float</span>
<span class="sd">            The amount of bounds tightening or new information that is leaned by the inference step.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"lifted"</span><span class="p">):</span>
            <span class="n">operands_world</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">world</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_world</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">operands_world</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                            <span class="n">operands_world</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                        <span class="p">],</span>
                        <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ WORLD FREE-VARIABLE UPDATED "</span>
                    <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upward_bounds</span> <span class="o">=</span> <span class="n">_gm</span><span class="o">.</span><span class="n">upward_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">,</span> <span class="n">groundings</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">upward_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># contradiction arresting</span>
                <span class="k">return</span>
            <span class="n">input_bounds</span><span class="p">,</span> <span class="n">groundings</span> <span class="o">=</span> <span class="n">upward_bounds</span>
            <span class="n">grounding_rows</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">None</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span>
                <span class="k">else</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">groundings</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">input_bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">input_bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">input_bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">],</span>
                <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_bounds</span><span class="p">(</span><span class="n">grounding_rows</span><span class="p">,</span> <span class="n">input_bounds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ BOUNDS UPDATED "</span>
                    <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Congruent.downward"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Congruent.downward">[docs]</a>    <span class="k">def</span> <span class="nf">downward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">groundings</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Downward inference from the operator to the operands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, optional</span>
<span class="sd">            restricts downward inference to an operand at the specified index. If unspecified, all operands are updated.</span>
<span class="sd">        groundings : str or tuple of str, optional</span>
<span class="sd">            restrict upward inference to a specific grounding or row in the truth table</span>
<span class="sd">        lifted : bool, optional</span>
<span class="sd">            flag that determines if lifting should be done on this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tightened_bounds : float</span>
<span class="sd">            The amount of bounds tightening or new information that is leaned by the inference step.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"lifted"</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">op_idx</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">):</span>
                <span class="n">op_aggregate</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_world</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">op_aggregate</span>
                <span class="k">if</span> <span class="n">op_aggregate</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s2">"↓ WORLD FREE-VARIABLE UPDATED "</span>
                        <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">op_aggregate</span><span class="si">}</span><span class="s2"> "</span>
                        <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                        <span class="sa">f</span><span class="s2">"FROM:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                        <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                        <span class="sa">f</span><span class="s2">"PARENT:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">downward_bounds</span> <span class="o">=</span> <span class="n">_gm</span><span class="o">.</span><span class="n">downward_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">,</span> <span class="n">groundings</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">downward_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># contradiction arresting</span>
                <span class="k">return</span>
            <span class="n">parent</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">groundings</span> <span class="o">=</span> <span class="n">downward_bounds</span>
            <span class="n">op_indices</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="p">([(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">index</span><span class="p">])])</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">op_index</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">op_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">propositional</span><span class="p">:</span>
                    <span class="n">op_grounding_rows</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">groundings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">op_grounding_rows</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">op_grounding_rows</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">groundings</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">g_i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">groundings</span><span class="p">):</span>
                            <span class="n">op_g</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">partial_grounding</span><span class="p">[</span><span class="n">slot</span><span class="p">])</span>
                                <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand_map</span><span class="p">[</span><span class="n">op_index</span><span class="p">]</span>
                            <span class="p">]</span>
                            <span class="n">op_g</span> <span class="o">=</span> <span class="n">_Grounding</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">op_g</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op_g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">op_g</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">op_grounding_rows</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op_g</span><span class="p">)</span>
                <span class="n">op_aggregate</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_bounds</span><span class="p">(</span><span class="n">op_grounding_rows</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">op_aggregate</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s2">"↓ BOUNDS UPDATED "</span>
                        <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">op_aggregate</span><span class="si">}</span><span class="s2"> "</span>
                        <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                        <span class="sa">f</span><span class="s2">"FROM:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                        <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                        <span class="sa">f</span><span class="s2">"PARENT:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">op_aggregate</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">extract_congruency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">formulae</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">formula</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">formulae</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">formula</span><span class="o">.</span><span class="n">congruent_nodes</span><span class="p">:</span>
                <span class="n">formula</span><span class="o">.</span><span class="n">congruent_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_congruency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">formula</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">formula</span><span class="o">.</span><span class="n">congruent_nodes</span><span class="p">:</span>
                <span class="n">formula</span><span class="o">.</span><span class="n">congruent_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">upward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">groundings</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"lifted"</span><span class="p">):</span>
            <span class="n">operands_world</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">world</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_world</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">operands_world</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                            <span class="n">operands_world</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                        <span class="p">],</span>
                        <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ WORLD FREE-VARIABLE UPDATED "</span>
                    <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upward_bounds</span> <span class="o">=</span> <span class="n">_gm</span><span class="o">.</span><span class="n">upward_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">,</span> <span class="n">groundings</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">upward_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># contradiction arresting</span>
                <span class="k">return</span>
            <span class="n">input_bounds</span><span class="p">,</span> <span class="n">groundings</span> <span class="o">=</span> <span class="n">upward_bounds</span>
            <span class="n">grounding_rows</span> <span class="o">=</span> <span class="p">(</span>
                <span class="kc">None</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">propositional</span>
                <span class="k">else</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">groundings</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grounding_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groundings</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">input_bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">input_bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">input_bounds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">],</span>
                <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron</span><span class="o">.</span><span class="n">aggregate_bounds</span><span class="p">(</span><span class="n">grounding_rows</span><span class="p">,</span> <span class="n">input_bounds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">"↑ BOUNDS UPDATED "</span>
                    <span class="sa">f</span><span class="s2">"TIGHTENED:</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> "</span>
                    <span class="sa">f</span><span class="s2">"FOR:'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">' "</span>
                    <span class="sa">f</span><span class="s2">"FORMULA:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">formula_number</span><span class="si">}</span><span class="s2"> "</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Function"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Function">[docs]</a><span class="k">class</span> <span class="nc">Function</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">"""Creates functions in first-order logic formulae</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    name : str</span>
<span class="sd">        name of the function</span>
<span class="sd">    term : Variable, str, Grounding, or tuple of their combination</span>
<span class="sd">        function arguments</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    plus_func = Function('plus', X, Y)</span>
<span class="sd">    x, y, z = Variables('x', 'y', 'z')</span>
<span class="sd">    ```</span>
<span class="sd">    """</span>

    <span class="c1"># Add output arity</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">""</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1"># The arity is expected to be known at construction.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span> <span class="o">=</span> <span class="n">input_dim</span>

        <span class="c1"># Constants and functions seen so far for each dimension.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groundings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="s2">""</span>
        <span class="k">for</span> <span class="n">arg_pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">+=</span> <span class="s2">"dim_"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg_pos</span><span class="p">)</span> <span class="o">+</span> <span class="s2">", "</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">"("</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s2">")"</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">_Grounding</span><span class="p">,</span>
            <span class="n">List</span><span class="p">[</span><span class="n">_Grounding</span><span class="p">],</span>
            <span class="nb">str</span><span class="p">,</span>
            <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="s2">"Variable"</span><span class="p">,</span>
            <span class="n">List</span><span class="p">[</span><span class="s2">"Variable"</span><span class="p">],</span>
            <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">_Grounding</span><span class="p">,</span> <span class="s2">"Variable"</span><span class="p">]],</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">_Grounding</span><span class="p">,</span> <span class="s2">"Function"</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Calls a function with arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ------------</span>
<span class="sd">            args : List of _Grounding and/or output of called Function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ```python</span>
<span class="sd">        y = plus_func(zero, one)</span>
<span class="sd">        ```</span>
<span class="sd">        """</span>

        <span class="c1"># If no input provided, it must map all available groundings.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">"expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="si">}</span><span class="s2"> arguments"</span> <span class="sa">f</span><span class="s2">"Received </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_Grounding</span><span class="p">))</span> <span class="k">else</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">args</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="c1"># Full grounding</span>
            <span class="n">ground_str</span> <span class="o">=</span> <span class="s2">""</span>
            <span class="n">grounding</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">arg_pos</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                <span class="n">ground_str</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">", "</span>
                <span class="n">grounding</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grounding</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">grounding</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">grounding</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grounding</span> <span class="o">=</span> <span class="p">(</span><span class="n">grounding</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
            <span class="n">ground_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groundings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">grounding</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ground_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ground_out</span> <span class="o">=</span> <span class="n">_Grounding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">"("</span> <span class="o">+</span> <span class="n">ground_str</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s2">")"</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">groundings</span><span class="p">[</span><span class="n">grounding</span><span class="p">]</span> <span class="o">=</span> <span class="n">ground_out</span>

            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">ground_out</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]):</span>
            <span class="c1"># All variables</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># If not all groundings or variables we have a binding.</span>
        <span class="n">bindings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">arg_pos</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
                <span class="n">bindings</span><span class="p">[</span><span class="n">arg_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_Grounding</span><span class="p">):</span>
                <span class="n">bindings</span><span class="p">[</span><span class="n">arg_pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">"Expected str, _Grounding, Variable, "</span>
                        <span class="sa">f</span><span class="s2">"tuple or Function. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span></div>


<div class="viewcode-block" id="Functions"><a class="viewcode-back" href="../../../lnn/LNN.html#lnn.Functions">[docs]</a><span class="k">def</span> <span class="nf">Functions</span><span class="p">(</span><span class="o">*</span><span class="n">functions</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Instantiates multiple functions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    ```python</span>
<span class="sd">    f1, f2 = Functions("f1", "f2", input_dim=2)</span>
<span class="sd">    ```</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">return1</span><span class="p">([</span><span class="n">Function</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">])</span></div>
</pre>
       </div>
      </article>
     </div>
    </div>
   </main>
  </div>
  <footer class="md-footer">
   <div class="md-footer-nav">
    <nav class="md-footer-nav__inner md-grid">
    </nav>
   </div>
   <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
     <div class="md-footer-copyright">
      <div class="md-footer-copyright__highlight">
       © Copyright 2022, IBM Research.
      </div>
      Created using
      <a href="http://www.sphinx-doc.org/">
       Sphinx
      </a>
      4.3.0.
             and
      <a href="https://github.com/bashtage/sphinx-material/">
       Material for
              Sphinx
      </a>
     </div>
    </div>
   </div>
  </footer>
  <script src="../../../_static/javascripts/application.js">
  </script>
  <script>
   app.initialize({version: "1.0.4", url: {base: ".."}})
  </script>
 </body>
</html>